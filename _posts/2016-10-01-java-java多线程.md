---
layout: post
title: java多线程
categories: java
tags: [java]
fullview: true
---

# Java多线程

* 扩展java.lang.Thread类
* 实现java.lang.Runnable接口
* Thread和Runnable的区别
* 线程状态转换
* 线程调度
* 常用函数
* 使用方式
* join方法
* 常见线程名字解释
* 线程同步
* 线程数据传递

		进程：每个进程都有独立的代码和数据空间（进程上下文），进程间的切换会有较大的开销，一个进程包		含1--n个线程
		线程：同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器(PC)，线程切换开销小。
		线程和进程一样分为五个阶段：创建、就绪、运行、阻塞、终止。
		多进程是指操作系统能同时运行多个任务（程序）。
		多线程是指在同一程序中有多个顺序流在执行。

在java中要想实现多线程，有两种手段，一种是继续Thread类，另外一种是实现Runable接口。

		实际上所有的多线程代码都是通过运行Thread的start()方法来运行的。因此，不管是扩展Thread类还是实现Runnable接口来实现多线程，最终还是通过Thread的对象的API来控制线程的，熟悉Thread类的API是进行多线程编程的基础

### Thread和Runnable的区别
如果一个类继承了Thread, 则不适合资源共享。但是如果实现了Runnable接口的话，则很容易实现资源共享。

### 线程状态转换
1. 新建状态(new): 新创建了一个线程对象
2. 就绪状态(runnable): 线程对象创建后，其它线程调用了该对象的start()方法。该状态的线程位于可运行线程池中, 变得可运行, 等待获取cup的使用权。
3. 运行状态(running): 就绪状态的线程获取了cpu，执行程序代码。
4. 阻塞状态(Blocked): 阻塞状态是线程因为某种原因放弃了cpu使用权,暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞状态分为三种：
	1. 等待阻塞: 运行的线程执行wait()方法, jvm会把该线程放入等待池中。
	2. 同步阻塞: 运行的线程在获取对象的同步锁时, 若该同步锁被别的线程占用，则jvm会把该线程放入锁池中。
	3. 其它阻塞: 运行的线程执行sleep()和join()方法, 或者发出了i/o请求时, jvm会把该线程置为阻塞状态。但sleep()状态超时、join()等待线程中止或者超时、或者i/o处理完毕时，线程重新转入就绪状态。
5. 死亡状态(dead): 线程执行完了或者因异常退出了run()方法，该线程结束生命周期

### 线程调度
1. 调整线程的优先级： 优先级高的线程会获得较多的运行机会。java的线程优先级用整数表示，取值范围是1～10，Thread类有以下三个静态常量:
	* static int MAX_PRIORITY: 线程可以具有的最高优先级，取值为10
	* static int MIN_PRIORITY: 线程可以具有的最低优先级，取值为1。
	* static int NORM_PRIORITY: 分配给线程的默认优先级，取值为5。
	(Thread类的setPriority()和getPriority()方法分别用来设置和获取线程的优先级)
2. 线程睡眠：Thread.sleep(long millis)方法，使线程转到阻塞状态。millis参数设定睡眠的时间，以毫秒为单位。当睡眠结束后，就转为就绪（Runnable）状态。sleep()平台移植性好。
3. 线程等待：Object类中的wait()方法，导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 唤醒方法。这个两个唤醒方法也是Object类中的方法，行为等价于调用 wait(0) 一样。
4. 线程让步：Thread.yield() 方法，暂停当前正在执行的线程对象，把执行机会让给相同或者更高优先级的线程。
5. 线程加入：join()方法，等待其他线程终止。在当前线程中调用另一个线程的join()方法，则当前线程转入阻塞状态，直到另一个进程运行结束，当前线程再由阻塞转为就绪状态。
6. 线程唤醒：Object类中的notify()方法，唤醒在此对象监视器上等待的单个线程。

### 常用函数说明
1. sleep(long millis): 在指定的毫秒数内让当前正在执行的线程休眠(暂停执行)
2. join():等待线程终止
3. yeild():暂停当前正在执行的线程对象，并执行其他线程（使用yield()的目的是让相同优先级的线程之间能适当的轮转执行）
4. setPriority(): 更改线程的优先级。
5. interrupt():中断某个线程，这种结束方式比较粗暴，如果t线程打开了某个资源还没来得及关闭也就是run方法还没有执行完就强制结束线程，会导致资源无法关闭
6. wait(): Obj.wait()，与Obj.notify()必须要与synchronized(Obj)一起使用，也就是wait,与notify是针对已经获取了Obj锁进行操作
7. wait和sleep:
	1. Thread类的方法：sleep(),yield()等</br>
	   Object的方法：wait()和notify()等
	2.  每个对象都有一个锁来控制同步访问。Synchronized关键字可以和对象的锁交互，来实现线程的同步。 </br>
 	sleep方法没有释放锁，而wait方法释放了锁，使得其他线程可以使用同步控制块或者方法。
 	3. wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用
 	4. sleep必须捕获异常，而wait，notify和notifyAll不需要捕获异常</br>


 			所以sleep()和wait()方法的最大区别是：
 			sleep()睡眠时，保持对象锁，仍然占有该锁；
 			而wait()睡眠时，释放对象锁。
 			但是wait()和sleep()都可以通过interrupt()方法打断线程的暂停状态，从而使线程立刻抛出InterruptedException（但不建议使用该方法）。


### 线程名词解释
* 主线程：JVM调用程序main()所产生的线程
* 当前线程：这个是容易混淆的概念。一般指通过Thread.currentThread()来获取的进程。
* 后台线程：指为其他线程提供服务的线程，也称为守护线程。JVM的垃圾回收线程就是一个后台线程。用户线程和守护线程的区别在于，是否等待主线程依赖于主线程结束而结束
* 前台线程：是指接受后台线程服务的线程
* 线程类的一些常用方法:
	1. sleep(): 强迫一个线程睡眠Ｎ毫秒。
	2. isAlive(): 判断一个线程是否存活。
	3. join(): 等待线程终止。
	4. activeCount(): 程序中活跃的线程数。
	5. enumerate(): 枚举程序中的线程。
	6. currentThread(): 得到当前线程。
	7. isDaemon(): 一个线程是否为守护线程
	8. setDaemon(): 设置一个线程为守护线程。(用户线程和守护线程的区别在于，是否等待主线程依赖于主线程结束而结束)
	9. setName(): 为线程设置一个名称。
	10. wait(): 强迫一个线程等待。
	11. notify(): 通知一个线程继续运行。
	12. setPriority(): 设置一个线程的优先级。

### 数据传递

1. 构造函数传入
2. get set方法传入
